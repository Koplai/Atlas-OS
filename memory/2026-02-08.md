- Configuré el modelo principal de OpenClaw a ollama/deepseek-r1:32b para ahorrar tokens (mantengo GPT-5.2 como fallback). 
- Creamos workflow LTM-Qdrant-Bridge con embedding nomic-embed-text + Qdrant y quedó listo para importar/activar en n8n; tú puedes activarlo desde la UI (ya te mandé el JSON). 
- Diseñamos estrategia dual: TikTok Shop España para afiliados tech gadgets (productos trending), y LinkedIn para posicionarte como MVP/MCT con contenido de IA/Copilot/AI Foundry/persona de agentes. 
- Lanzamos subagentes para generar ideas de nicho y temas de LinkedIn; ya tienes posts e ideas concretas.
- Instalé Chromium + habilité el browser control para poder acceder a flow.jpmarquez.com si Cloudflare Access lo permite, y hablamos del dashboard que quieres: costos, modelos instalados, logs, skills, etc.
- Tenemos un plan de dashboard en bot.jpmarquez.com o subdominio, con visual tech y controles para monitorizar bots, budgets y opciones de configuración.
- Se creó el proyecto Next.js en /root/.openclaw/workspace/dashboard/atlas-dashboard (create-next-app exitoso) para el dashboard.
- Reajusté el modelo principal a ollama/deepseek-r1:32b en openclaw.json y verifiqué con jq + ollama list; el fallback GPT se usa si falla el local.
- Quedó documentado el protocolo de integridad: no afirmar acciones sin evidencia, estados (PLANNING/EXECUTING/VERIFIED), y pruebas obligatorias.

## Hoy (2026-02-08):
- Discutimos beneficios de arquitectura multi-agente: especialización, aislamiento de fallos, escalado independiente, paralelismo, seguridad, trazabilidad, mantenibilidad, optimización coste/eficiencia.
- Propuse asignación de modelos por agente (local para rutina, cloud para análisis/creatividad) + supervisión/watchdog para resiliencia anti-bloqueo.
- Detectamos fallo 401 en memoria (embeddings OpenAI); propuse plan de resiliencia: Qdrant local + embeddings locales (Ollama/nomic) + fallbacks duales + cache + workflow n8n como proxy.
- Confirmaste enfoque multi-API/multi-proveedor: cada agente con su API key, límites y fallbacks.
- Decidimos nombre del equipo: **Atlas Ops** (técnico/infra).
- Estrategia de modelos: **balance** coste/calidad; **Llama 3.2 local** como default para conversación, **DeepSeek local** para análisis técnico, **OpenRouter** como fallback.
- Configuré modelo default y agente principal (pm/Atlas) a **ollama/llama3.2:3b** para reducir consumo de tokens en comunicación; mantuve deepseek-r1:32b para roles analíticos (backend, data-ai).
- Modelos ya instalados: llama3.2:3b, llama3:latest, deepseek-r1:32b, nomic-embed-text:latest.
- **Configurada resiliencia de memoria (15:00):**
  - Embeddings locales: Ollama API (http://localhost:11434/v1) con nomic-embed-text (768 dims)
  - Vector store: SQLite + sqlite-vec en ~/.openclaw/memory/atlas.sqlite
  - Búsqueda híbrida: vector (70%) + BM25 (30%), 6 resultados max, minScore 0.3
  - Sincronización: on session start, lazy on search, watch files (debounce 1s)
  - Cache de embeddings: hasta 10k entradas
  - Fallback: ninguno (todo local, sin OpenAI)
  - Colección Qdrant creada: openclaw_memory (768 dims, Cosine)
- **Health check + fallback automático (15:07):**
  - Creado script `scripts/health-check-ollama.sh` (checks API + embeddings, auto-restart con --fix)
  - Configurado fallback OpenRouter (claude-sonnet-4.5) para todos los agentes con modelos locales
  - Si Ollama falla → switch automático a OpenRouter sin intervención manual
  - Documentada stack completa en `RESILIENCE.md`
- **Watchdog para sesiones bloqueadas (15:09):**
  - Creado `scripts/watchdog-sessions.sh` (checks heartbeats cada 5min vía cron)
  - Reinicia gateway automáticamente si >15min sin heartbeats
  - Alertas vía Telegram + log en `memory/incidents.md`
  - Verificado que gateway corre bajo systemd (`openclaw-gateway.service`) con `Restart=always`
  - Cron job configurado (e66bb9e2-e948-4ae5-a658-e953df09429a)
- **Incidente 14:55:** Sistema se reinició sin handoff suave; tuviste que cerrar/abrir terminal manualmente.
- **Solución:** Renombrado agente `pm` → `atlas` para coincidir con IDENTITY.md; añadido protocolo anti-bloqueo en SOUL.md; creado memory/incidents.md y state-checkpoint.json para tracking y recuperación.
- **Protocolo de resiliencia activo:** checkpoint antes de restart, notificación explícita, recuperación automática de contexto.
